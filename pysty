#!/usr/bin/env python
import sys
import urllib2
import urlparse
import cookielib
import os
import readline
import atexit

class Pysty:

    # -------------------------------------------------------------------------
    # Initialisation
    # -------------------------------------------------------------------------

    def __init__(self, base_url):
        self._sane_defaults()
        self._base_url = base_url
        self._cookiejar = cookielib.CookieJar()
        self._opener = \
            urllib2.build_opener(urllib2.HTTPCookieProcessor(self._cookiejar))

        # XXX: Hardcoded
        self._headers['Accept'] = 'application/json'
        self._headers['Content-Type'] = 'application/json'

        # Readline
        self._init_readline()

    def _sane_defaults(self):
        self._headers = {}
        self._base_url = None
        self._cookiejar = None

    # -------------------------------------------------------------------------
    # Helpers
    # -------------------------------------------------------------------------

    def _process_request(self, args):
        path, json = self._split(args)
        full_url = urlparse.urljoin(self._base_url, path)
        return full_url, json

    def _split(self, str):
        bits = str.split(' ', 1)
        first = bits[0]
        try:
            second = bits[1]
        except IndexError:
            second = None
        return first, second

    def _draw_line(self):
        try:
            _, columns = os.popen('stty size', 'r').read().split()
        except:
            columns = 80

        print '-' * int(columns)

    def _generic_request(self, args, method):
        url, json = self._process_request(args)
        self._send_request(method, url, json)

    def _send_request(self, method, url, data):
        self._draw_line()
        print '%(method)s %(url)s %(data)s' % locals()
        request = urllib2.Request(url, data=data, headers=self._headers)
        request.get_method = lambda: method

        try:
            f = self._opener.open(request)
        except urllib2.HTTPError, f:
            print f
        
        info = f.info()

        self._draw_line()
        print(info)

        data = f.read()

        self._draw_line()
        self._pretty_print(data)

    def _pretty_print(self, code):
        try:
            from pygments import highlight
            from pygments.lexers import guess_lexer
            from pygments.formatters import TerminalFormatter
        except ImportError, e:
            print e
            print code
            return

        lexer = guess_lexer(code)
        print highlight(code, lexer, TerminalFormatter())

    # -------------------------------------------------------------------------
    # Command Execution
    # -------------------------------------------------------------------------

    def _cli_execute(self, cmd):
        command, args = self._split(cmd)
        try:
            method = getattr(self, command.lower())
        except AttributeError:
            print('%(cmd)s not found' % locals())
            return

        method(args)

    # -------------------------------------------------------------------------
    # Commands
    # -------------------------------------------------------------------------

    def header_set(self, args):
        key, value = args.split(' ')
        self._headers[key] = value

    def header_list(self, args):
        for k, v in self._headers.items():
            print k, v

    def quit(self, args):
        sys.exit(0)

    exit = quit

    def get(self, args):
        self._generic_request(args, 'GET')

    def post(self, args):
        self._generic_request(args, 'POST')

    def put(self, args):
        self._generic_request(args, 'PUT')

    def delete(self, args):
        self._generic_request(args, 'DELETE')

    # -------------------------------------------------------------------------
    # Readline
    # -------------------------------------------------------------------------

    def _init_readline(self):
        
        # settings for tab completion and reverse search
        if sys.platform == 'darwin':
            readline.parse_and_bind("bind ^I rl_complete")
            readline.parse_and_bind("bind ^r em-inc-search-prev")
        else:
            readline.parse_and_bind('tab: complete')

        # completion
        readline.set_completer(self._auto_complete)

        # save/load history
        histfile = os.path.join(os.environ["HOME"], ".pysty_history")
        try:
            readline.read_history_file(histfile)
        except IOError:
            pass
        atexit.register(readline.write_history_file, histfile)

    def _auto_complete(self, text, state):
        methods = filter(lambda a: not a.startswith('_'), dir(self))
        c = 0
        for method in methods:
            if method.startswith(text):
                if state != c:
                    c += 1
                    continue
                return method

    def loop(self):
        while 1:
            self._cli_execute(raw_input('%s> ' % self._base_url))


def main():

    base_url = sys.argv[1]
    pysty = Pysty(base_url)
    pysty.loop()


if __name__ == '__main__': 
    main()    


